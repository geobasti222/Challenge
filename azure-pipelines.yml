# azure-pipelines.yml
trigger:
  branches:
    include:
      - master
      - develop

pr:
  branches:
    include:
      - master
      - develop

variables:
  - name: buildConfiguration
    value: 'Release'
  - name: vmImage
    value: 'ubuntu-latest'
  - name: solution
    value: 'Challenge.sln'
  - name: testProject
    value: 'Tests/**/*.csproj'
  
  # Docker/ACR
  - name: acrServiceConnection
    value: 'challengeserviceconnection'
  - name: acrName
    value: 'challenge.azurecr.io'
  - name: imageName
    value: 'devops-api'
  - name: dockerfilePath
    value: 'Devops.Api/Dockerfile'
  
  # AKS Configuration
  - name: azureServiceConnection
    value: 'MychallengeServiceConnection'
  - name: aksResourceGroup
    value: 'Challenge'
  - name: aksClusterName
    value: 'akschalle'
  - name: aksNamespaceDev
    value: 'devops-app-dev'
  - name: aksNamespaceProd
    value: 'devops-app-prod'

stages:
# STAGE 1: BUILD Y TEST
- stage: Build_Test
  displayName: 'Build and Test'
  jobs:
  - job: Build
    displayName: 'Build and Test Application'
    pool:
      vmImage: $(vmImage)
    
    steps:
    # GESTIÓN DE DEPENDENCIAS
    - task: UseDotNet@2
      displayName: 'Use .NET 8.0'
      inputs:
        packageType: 'sdk'
        version: '8.0.x'

    - task: DotNetCoreCLI@2
      displayName: 'Restore Dependencies'
      inputs:
        command: 'restore'
        projects: $(solution)

    # ANÁLISIS ESTÁTICO DE CÓDIGO
    - task: DotNetCoreCLI@2
      displayName: 'Install dotnet-format tool'
      inputs:
        command: 'custom'
        custom: 'tool'
        arguments: 'install --global dotnet-format'
      condition: succeeded()

    - task: CmdLine@2
      displayName: 'Apply code formatting'
      inputs:
        script: 'dotnet format --verbosity minimal'
      condition: succeeded()

    # BUILD
    - task: DotNetCoreCLI@2
      displayName: 'Build Solution'
      inputs:
        command: 'build'
        projects: $(solution)
        arguments: '--configuration $(buildConfiguration) --no-restore'

    # PRUEBAS AUTOMATIZADAS
    - task: DotNetCoreCLI@2
      displayName: 'Run Unit Tests'
      inputs:
        command: 'test'
        projects: $(testProject)
        arguments: '--configuration $(buildConfiguration) --no-build --logger trx --collect:"XPlat Code Coverage"'
        publishTestResults: true

    # CONTAINERIZACIÓN
    - task: Docker@2
      displayName: 'Build and Push Docker Image'
      inputs:
        command: 'buildAndPush'
        repository: $(imageName)
        dockerfile: $(dockerfilePath)
        containerRegistry: $(acrServiceConnection)
        tags: |
          $(Build.BuildId)
          latest

    # PUBLICAR MANIFIESTOS COMO ARTEFACTO
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Kubernetes Manifests'
      inputs:
        PathtoPublish: 'manifests'
        ArtifactName: 'manifests'

# STAGE 2: DEPLOY TO DEVELOPMENT
- stage: Deploy_Dev
  displayName: 'Deploy to Development'
  dependsOn: Build_Test
  condition: |
    and(
      succeeded(),
      or(
        eq(variables['Build.SourceBranch'], 'refs/heads/develop'),
        startsWith(variables['Build.SourceBranch'], 'refs/heads/feature/')
      )
    )
  jobs:
  - deployment: Deploy_Development
    displayName: 'Deploy to Development'
    pool:
      vmImage: $(vmImage)
    environment: 'Development'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
          - download: current
            artifact: manifests

          - task: Bash@3
            displayName: 'Verify Kustomize Structure'
            inputs:
              targetType: 'inline'
              script: |
                echo "=== VERIFICANDO ESTRUCTURA KUSTOMIZE ==="
                find $(Pipeline.Workspace)/manifests -name "*.yaml" -type f | sort
                echo ""
                echo "=== CONTENIDO DE BASE/KUSTOMIZATION.YAML ==="
                cat $(Pipeline.Workspace)/manifests/base/kustomization.yaml
                echo ""
                echo "=== CONTENIDO DE DEVELOPMENT/KUSTOMIZATION.YAML ==="
                cat $(Pipeline.Workspace)/manifests/development/kustomization.yaml

          - task: AzureCLI@2
            displayName: 'Deploy to AKS (Development)'
            inputs:
              azureSubscription: $(azureServiceConnection)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                set -e
                echo "=== DESPLIEGUE EN DESARROLLO ==="
                
                az aks get-credentials --resource-group $(aksResourceGroup) --name $(aksClusterName) --overwrite-existing
                
                echo "=== APLICANDO KUSTOMIZE ==="
                # Probar primero en modo dry-run
                kubectl apply -k $(Pipeline.Workspace)/manifests/development/ --dry-run=client -o yaml
                
                # Aplicar realmente
                kubectl apply -k $(Pipeline.Workspace)/manifests/development/
                
                echo "=== VERIFICANDO DESPLIEGUE ==="
                kubectl rollout status deployment/devops-api -n devops-app-dev --timeout=180s
                kubectl get all -n devops-app-dev
                
                echo "✅ DESARROLLO DESPLEGADO EXITOSAMENTE"

# STAGE 3: DEPLOY TO PRODUCTION - CON DIAGNÓSTICO
- stage: Deploy_Prod
  displayName: 'Deploy to Production'
  dependsOn: Build_Test
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))
  jobs:
  - deployment: Deploy_Production
    displayName: 'Deploy to Production'
    pool:
      vmImage: $(vmImage)
    environment: 'Production'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
          - download: current
            artifact: manifests

          - task: AzureCLI@2
            displayName: 'Configure ACR Access for AKS'
            inputs:
              azureSubscription: $(azureServiceConnection)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "=== CONFIGURANDO ACCESO ACR PARA AKS ==="
                az aks update --resource-group $(aksResourceGroup) --name $(aksClusterName) --attach-acr challenge
                echo "✅ AKS configurado para acceder al ACR"

          - task: Bash@3
            displayName: 'Update Production Image Tag'
            inputs:
              targetType: 'inline'
              script: |
                echo "=== ACTUALIZANDO TAG DE IMAGEN ==="
                echo "Build ID: $(Build.BuildId)"
                sed -i "s|BUILD_TAG_PLACEHOLDER|$(Build.BuildId)|g" $(Pipeline.Workspace)/manifests/production/kustomization.yaml
                echo "✅ Kustomization actualizado"

          - task: AzureCLI@2
            displayName: 'Deploy to AKS (Production)'
            inputs:
              azureSubscription: $(azureServiceConnection)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                set -e
                echo "=== DESPLIEGUE EN PRODUCCIÓN ==="
                
                az aks get-credentials --resource-group $(aksResourceGroup) --name $(aksClusterName) --overwrite-existing
                
                # Verificar que la imagen existe en ACR
                echo "=== VERIFICANDO IMAGEN EN ACR ==="
                az acr repository show-tags --name challenge --repository devops-api --output table
                
                echo "=== APLICANDO CONFIGURACIÓN ==="
                kubectl apply -k $(Pipeline.Workspace)/manifests/production/
                
                echo "=== MONITOREANDO DESPLIEGUE EN TIEMPO REAL ==="
                
                # Iniciar monitoreo en background
                kubectl get pods -n devops-app-prod -w &
                MONITOR_PID=$!
                
                # Esperar un poco para que los pods empiecen
                sleep 30
                
                # Verificar estado de los pods inmediatamente
                echo "=== ESTADO INICIAL DE PODS ==="
                kubectl get pods -n devops-app-prod -o wide
                
                # Verificar eventos para diagnóstico
                echo "=== EVENTOS DEL CLUSTER ==="
                kubectl get events -n devops-app-prod --sort-by='.lastTimestamp'
                
                # Verificar detalles del deployment
                echo "=== DETALLES DEL DEPLOYMENT ==="
                kubectl describe deployment devops-api -n devops-app-prod
                
                # Intentar rollout status con timeout
                echo "=== ESPERANDO DESPLIEGUE (con timeout de 5 minutos) ==="
                if timeout 300s kubectl rollout status deployment/devops-api -n devops-app-prod; then
                  kill $MONITOR_PID 2>/dev/null
                  echo "🎉 ✅ PRODUCCIÓN DESPLEGADA EXITOSAMENTE"
                  echo "📊 Estado final:"
                  kubectl get all -n devops-app-prod
                else
                  kill $MONITOR_PID 2>/dev/null
                  echo "❌ TIMEOUT - DESPLIEGUE NO COMPLETADO EN 5 MINUTOS"
                  echo "=== DIAGNÓSTICO DETALLADO ==="
                  
                  # Obtener información detallada de los pods
                  echo "1. PODS Y SUS ESTADOS:"
                  kubectl get pods -n devops-app-prod -o wide
                  
                  echo "2. DESCRIPCIÓN DE PODS FALLIDOS:"
                  kubectl describe pods -n devops-app-prod -l app=devops-api
                  
                  echo "3. LOGS DE LOS PODS:"
                  kubectl logs -n devops-app-prod -l app=devops-api --all-containers=true --prefix=true --tail=50
                  
                  echo "4. EVENTOS RECIENTES:"
                  kubectl get events -n devops-app-prod --sort-by='.lastTimestamp' | tail -20
                  
                  echo "5. VERIFICAR IMAGE PULL:"
                  kubectl describe pods -n devops-app-prod -l app=devops-api | grep -A 10 -B 10 "Image"
                  
                  echo "6. VERIFICAR RECURSOS:"
                  kubectl top pods -n devops-app-prod 2>/dev/null || echo "Metrics no disponibles"
                  
                  exit 1
                fi

          # Continuar con API Management solo si el despliegue fue exitoso
          - task: AzureCLI@2
            displayName: 'Configure API Management'
            condition: succeeded()
            inputs:
              azureSubscription: $(azureServiceConnection)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "=== CONFIGURANDO API MANAGEMENT ==="
                
                # Obtener IP externa del servicio
                echo "Obteniendo IP del servicio..."
                SERVICE_IP=$(kubectl get service devops-api-service -n devops-app-prod -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
                
                if [ -n "$SERVICE_IP" ]; then
                  echo "✅ IP del servicio: $SERVICE_IP"
                  
                  # Configurar API Management
                  if az apim api show --resource-group Challenge --service-name apim-devops-challenge --api-id 'devops-api-prod' &>/dev/null; then
                    echo "🔄 Actualizando API existente..."
                    az apim api update \
                      --resource-group Challenge \
                      --service-name apim-devops-challenge \
                      --api-id 'devops-api-prod' \
                      --service-url "http://$SERVICE_IP"
                  else
                    echo "📝 Creando nueva API..."
                    az apim api create \
                      --resource-group Challenge \
                      --service-name apim-devops-challenge \
                      --api-id 'devops-api-prod' \
                      --display-name 'DevOps API Production' \
                      --path 'api' \
                      --service-url "http://$SERVICE_IP" \
                      --protocols https
                  fi
                  echo "✅ API Management configurado"
                else
                  echo "⚠️  No se pudo obtener IP del servicio"
                fi