# azure-pipelines.yml
trigger:
  branches:
    include:
      - master
      - develop

pr:
  branches:
    include:
      - master
      - develop

variables:
  - name: buildConfiguration
    value: 'Release'
  - name: vmImage
    value: 'ubuntu-latest'
  - name: solution
    value: 'Challenge.sln'
  - name: testProject
    value: 'Tests/**/*.csproj'
  
  # Docker/ACR
  - name: acrServiceConnection
    value: 'challengeserviceconnection'
  - name: acrName
    value: 'challenge.azurecr.io'
  - name: imageName
    value: 'devops-api'
  - name: dockerfilePath
    value: 'Devops.Api/Dockerfile'
  
  # AKS Configuration
  - name: azureServiceConnection
    value: 'MychallengeServiceConnection'
  - name: aksResourceGroup
    value: 'Challenge'
  - name: aksClusterName
    value: 'akschalle'
  - name: aksNamespaceDev
    value: 'devops-app-dev'
  - name: aksNamespaceProd
    value: 'devops-app-prod'

stages:
# STAGE 1: BUILD Y TEST
- stage: Build_Test
  displayName: 'Build and Test'
  jobs:
  - job: Build
    displayName: 'Build and Test Application'
    pool:
      vmImage: $(vmImage)
    
    steps:
    # GESTIÓN DE DEPENDENCIAS
    - task: UseDotNet@2
      displayName: 'Use .NET 8.0'
      inputs:
        packageType: 'sdk'
        version: '8.0.x'

    - task: DotNetCoreCLI@2
      displayName: 'Restore Dependencies'
      inputs:
        command: 'restore'
        projects: $(solution)

    # ANÁLISIS ESTÁTICO DE CÓDIGO
    - task: DotNetCoreCLI@2
      displayName: 'Install dotnet-format tool'
      inputs:
        command: 'custom'
        custom: 'tool'
        arguments: 'install --global dotnet-format'
      condition: succeeded()

    - task: CmdLine@2
      displayName: 'Apply code formatting'
      inputs:
        script: 'dotnet format --verbosity minimal'
      condition: succeeded()

    # BUILD
    - task: DotNetCoreCLI@2
      displayName: 'Build Solution'
      inputs:
        command: 'build'
        projects: $(solution)
        arguments: '--configuration $(buildConfiguration) --no-restore'

    # PRUEBAS AUTOMATIZADAS
    - task: DotNetCoreCLI@2
      displayName: 'Run Unit Tests'
      inputs:
        command: 'test'
        projects: $(testProject)
        arguments: '--configuration $(buildConfiguration) --no-build --logger trx --collect:"XPlat Code Coverage"'
        publishTestResults: true

    # CONTAINERIZACIÓN
    - task: Docker@2
      displayName: 'Build and Push Docker Image'
      inputs:
        command: 'buildAndPush'
        repository: $(imageName)
        dockerfile: $(dockerfilePath)
        containerRegistry: $(acrServiceConnection)
        tags: |
          $(Build.BuildId)
          latest

    # PUBLICAR MANIFIESTOS COMO ARTEFACTO
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Kubernetes Manifests'
      inputs:
        PathtoPublish: 'manifests'
        ArtifactName: 'manifests'

# STAGE 2: DEPLOY TO DEVELOPMENT
- stage: Deploy_Dev
  displayName: 'Deploy to Development'
  dependsOn: Build_Test
  condition: |
    and(
      succeeded(),
      or(
        eq(variables['Build.SourceBranch'], 'refs/heads/develop'),
        startsWith(variables['Build.SourceBranch'], 'refs/heads/feature/')
      )
    )
  jobs:
  - deployment: Deploy_Development
    displayName: 'Deploy to Development'
    pool:
      vmImage: $(vmImage)
    environment: 'Development'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
          - download: current
            artifact: manifests

          - task: Bash@3
            displayName: 'Verify Kustomize Structure'
            inputs:
              targetType: 'inline'
              script: |
                echo "=== VERIFICANDO ESTRUCTURA KUSTOMIZE ==="
                find $(Pipeline.Workspace)/manifests -name "*.yaml" -type f | sort
                echo ""
                echo "=== CONTENIDO DE BASE/KUSTOMIZATION.YAML ==="
                cat $(Pipeline.Workspace)/manifests/base/kustomization.yaml
                echo ""
                echo "=== CONTENIDO DE DEVELOPMENT/KUSTOMIZATION.YAML ==="
                cat $(Pipeline.Workspace)/manifests/development/kustomization.yaml

          - task: AzureCLI@2
            displayName: 'Deploy to AKS (Development)'
            inputs:
              azureSubscription: $(azureServiceConnection)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                set -e
                echo "=== DESPLIEGUE EN DESARROLLO ==="
                
                az aks get-credentials --resource-group $(aksResourceGroup) --name $(aksClusterName) --overwrite-existing
                
                echo "=== APLICANDO KUSTOMIZE ==="
                # Probar primero en modo dry-run
                kubectl apply -k $(Pipeline.Workspace)/manifests/development/ --dry-run=client -o yaml
                
                # Aplicar realmente
                kubectl apply -k $(Pipeline.Workspace)/manifests/development/
                
                echo "=== VERIFICANDO DESPLIEGUE ==="
                kubectl rollout status deployment/devops-api -n devops-app-dev --timeout=180s
                kubectl get all -n devops-app-dev
                
                echo "✅ DESARROLLO DESPLEGADO EXITOSAMENTE"

# STAGE 3: DEPLOY TO PRODUCTION
- stage: Deploy_Prod
  displayName: 'Deploy to Production'
  dependsOn: Build_Test
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))
  jobs:
  - deployment: Deploy_Production
    displayName: 'Deploy to Production'
    pool:
      vmImage: $(vmImage)
    environment: 'Production'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
          - download: current
            artifact: manifests

          - task: AzureCLI@2
            displayName: 'Configure ACR Access for AKS'
            inputs:
              azureSubscription: $(azureServiceConnection)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "=== CONFIGURANDO ACCESO ACR PARA AKS ==="
                az aks update --resource-group $(aksResourceGroup) --name $(aksClusterName) --attach-acr challenge
                echo "✅ AKS configurado para acceder al ACR"

          - task: Bash@3
            displayName: 'Update Production Image Tag'
            inputs:
              targetType: 'inline'
              script: |
                echo "=== ACTUALIZANDO TAG DE IMAGEN ==="
                echo "Build ID: $(Build.BuildId)"
                
                # Convertir a string y reemplazar el placeholder
                sed -i "s|BUILD_TAG_PLACEHOLDER|$(Build.BuildId)|g" $(Pipeline.Workspace)/manifests/production/kustomization.yaml
                
                # Verificar el cambio
                echo "✅ Kustomization actualizado:"
                grep -A 2 -B 2 "newTag" $(Pipeline.Workspace)/manifests/production/kustomization.yaml

          - task: AzureCLI@2
            displayName: 'Deploy to AKS (Production)'
            inputs:
              azureSubscription: $(azureServiceConnection)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                set -e
                echo "=== DESPLIEGUE EN PRODUCCIÓN ==="
                
                az aks get-credentials --resource-group $(aksResourceGroup) --name $(aksClusterName) --overwrite-existing
                
                # Verificar que la imagen existe en ACR
                echo "=== VERIFICANDO IMAGEN EN ACR ==="
                az acr repository show-tags --name challenge --repository devops-api --output table
                
                # Verificar el kustomization antes de aplicar
                echo "=== VERIFICANDO KUSTOMIZATION ==="
                cat $(Pipeline.Workspace)/manifests/production/kustomization.yaml
                
                echo "=== APLICANDO CONFIGURACIÓN ==="
                kubectl apply -k $(Pipeline.Workspace)/manifests/production/
                
                echo "=== ESPERANDO DESPLIEGUE ==="
                # Esperar inicial para descarga de imagen
                sleep 45
                
                # Verificar estado con timeout extendido
                if kubectl rollout status deployment/devops-api -n devops-app-prod --timeout=600s; then
                  echo "🎉 ✅ PRODUCCIÓN DESPLEGADA EXITOSAMENTE"
                  echo "📊 Estado final:"
                  kubectl get all -n devops-app-prod
                  kubectl get hpa -n devops-app-prod
                else
                  echo "❌ FALLO EN EL DESPLIEGUE DE PRODUCCIÓN"
                  echo "=== DETALLES DEL ERROR ==="
                  kubectl describe deployment devops-api -n devops-app-prod
                  kubectl describe pods -n devops-app-prod -l app=devops-api
                  kubectl logs -n devops-app-prod -l app=devops-api --all-containers=true --tail=50
                  exit 1
                fi

          - task: AzureCLI@2
            displayName: 'Configure API Management'
            inputs:
              azureSubscription: $(azureServiceConnection)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "=== CONFIGURANDO API MANAGEMENT ==="
                
                # Obtener IP externa del servicio
                echo "Obteniendo IP del servicio..."
                kubectl get service devops-api-service -n devops-app-prod -o wide
                
                # Esperar a que la IP esté disponible
                COUNTER=0
                while [ $COUNTER -lt 12 ]; do
                  SERVICE_IP=$(kubectl get service devops-api-service -n devops-app-prod -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)
                  if [ -n "$SERVICE_IP" ]; then
                    echo "✅ IP del servicio: $SERVICE_IP"
                    break
                  fi
                  echo "Esperando IP del servicio... ($((COUNTER*30))s)"
                  sleep 30
                  COUNTER=$((COUNTER + 1))
                done
                
                if [ -n "$SERVICE_IP" ]; then
                  echo "Configurando API Management para: http://$SERVICE_IP"
                  
                  # Verificar si la API ya existe
                  if az apim api show --resource-group $(apimResourceGroup) --service-name $(apimServiceName) --api-id 'devops-api-prod' &>/dev/null; then
                    echo "✅ API ya existe, actualizando..."
                    az apim api update \
                      --resource-group $(apimResourceGroup) \
                      --service-name $(apimServiceName) \
                      --api-id 'devops-api-prod' \
                      --service-url "http://$SERVICE_IP"
                  else
                    echo "📝 Creando nueva API..."
                    az apim api create \
                      --resource-group $(apimResourceGroup) \
                      --service-name $(apimServiceName) \
                      --api-id 'devops-api-prod' \
                      --display-name 'DevOps API Production' \
                      --path 'api' \
                      --service-url "http://$SERVICE_IP" \
                      --protocols https \
                      --subscription-required true
                  fi
                  echo "✅ API Management configurado"
                else
                  echo "⚠️  No se pudo obtener IP del servicio, omitiendo API Management"
                fi